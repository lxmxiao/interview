## Set

set 包括：HashSet、LinkedHashSet 和 TreeSet

## HashMap

默认容量为 16

默认负载因子为 0.75

put 时判断 key 是否相等，同时判断 key 的 hashcode 是否相等

#### HashMap 和 ConcurrentMap 的区别

* hashMap 可以有 null 的键，concurrentMap 不可以有 
* hashMap 是线程不安全的，ConcurrentMap 使用了重入锁保证线程安全
* 在删除元素时候，两者的算法不一样

## ConcurrentMap

和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性

## 多线程

#### 线程池

* 优点

  * 避免线程的创建和销毁带来的性能开销
  * 避免大量的线程间因互相抢占系统资源导致的阻塞现象
  * 能够对线程进行简单的管理并提供定时执行、间隔执行等功能

* **四种线程池**

  * newCachedThreadPool 

    是一个可根据需要创建新线程的线程池（自动扩充）

  * newSingleThreadExecutor

    创建是一个单线程池，也就是该线程池只有一个线程在工作

  * **newFixedThreadPool**（常用）

    创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小

  * newScheduledThreadPool 

    创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求

## JVM

#### 虚拟机是怎样加载 Java 的

1. 加载

   加载 class 字节码文件

2. 验证

   这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

3. 准备

   准备阶段是正式为类变量(被static修饰的变量)分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配

4. 解析

   解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

5. 初始化

   在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源

6. 使用

7. 卸载

#### JVM 运行机制

Java 源文件 -> 编译器 -> 字节码文件 -> JVM -> 机器码

## 双亲委派模式

* 概念

  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载

* 好处

  Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，它放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类

* 分为三层

  1. 启动类加载器

      这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用

  2. 扩展类加载器

     这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器

  3. 应用程序类加载器

     这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器

* 实现自己的加载器

  只需要继承ClassLoader，并覆盖findClass方法。在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载